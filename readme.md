
线程带来的风险：
1、线程的安全性问题
	因为多个线程执行的顺序不可控制，所以会产生安全性问题
	产生的原因：
		多线程环境
		多个线程共享一个资源
		对资源进行非原子性操作
2、线程的活跃性问题
	死锁：
	饥饿：例如餐厅排队，一直抢不上
	活锁：
扩展：
	饥饿和公平：
	1、高优先级吞噬所有低优先级cpu的时间片  ---注意：高优先级的不一定就会比低优先级的快
	2、线程被永久堵塞在一个等待进入同步快的状态
	3、等待的线程永远不被唤醒
	
	如何尽量避免饥饿问题？
		设置合理的优先级
		使用锁来代替synchronized
	
3、线程的性能问题
	时间片：cpu分配给各个线程的事件
	上下文切换：(浪费性能)
	
javap -verbose Sequence.class

synchronized原理与使用
	synchronized的原理是有内置锁和互斥锁
内置锁
互斥锁

可以修饰普通方法、静态方法和代码块
monitorenter

monitorexit

任何对象都可以作为锁，那么锁信息存在对象的什么地方呢？
	存在对象的对象头中
对象头中的信息
	Mark Work --存的hash和对象的锁信息
	Class Metadata Address
	Array Length
1.6之前synchronized是重量锁
1.6之后又产生了集中锁
偏向锁：
	每次获得锁和释放锁会浪费资源
	很多情况下，竞争锁不是由多个线程，而是由一个线程在使用
	只有一个线程在访问同步代码块的场景
	
轻量级锁：
	自旋 while(true)
	多个线程同时
重量级锁：

单利模式和线程安全的问题？
	饿汉式
		没有线程安全的问题
	懒汉式
		双重检查锁可能会产生问题，原因是指令重排序--->避免产生这个原因在对象的属性中加上volatile关键字修饰即可

volatile 关键字
volatile称之为轻量级锁，被volatile修饰的变量，在线程之间是可见的
可见：一个线程改变了这个变量的值，在另外一个线程中能读到改变之后的值
synchronized除了线程间互斥以外，还有一个非常大的作用，就是保证可见性
volatile只能保证可见性，不能保证原子性

============
JDK提供的原子类原理及应用
原子更新基本类型
原子更新数组
原子更新抽象类型
原子更新字段









